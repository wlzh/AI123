

<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#f9f9f9" />

	<title>多模态的大一统之路 作者： AINLP 来源： AINLP 作者：aaronxic个人主页 原文地址：https://zhuanlan.zhihu.com/p/643969218 开篇 前面几篇我们已经了解了transformer是如何应用在LLM领域中，从这一篇开始我们进入多模态的领域，  | AI123| ai工具网址导航,ai最新产品</title>
	<link rel="shortcut icon" href="/assets/images/favicon.png" />
    <meta name="keywords" content="chatgpt,AI,AI聊天,AI文本生成,AI绘画,AI编程,AI电商" />
    <meta name="description" content="AI123 网址导航 | 免费chatgpt 汇集各类先进的人工智能产品，旨在帮助用户更快速地了解和使用这些产品,轻松地浏览不同领域的AI产品，包括语音识别、图像处理、自然语言处理。" />
    
    <meta name="baidu-site-verification" content="codeva-LoCoq3KOzQ" />
    
    <link rel="stylesheet" id="block-library-css"
        href="/assets/css/block-library.min-5.6.2.css" type="text/css" media="all" />
    <link rel="stylesheet" id="iconfont-css" href="/assets/css/iconfont-3.03029.1.css"
        type="text/css" media="all" />

    
    <link href="/scss/style.min.css" rel="stylesheet" />
    
		    <link rel="stylesheet" id="iowen-css" href="/assets/css/style-3.03029.1.css"
        type="text/css" media="all" />
    <link rel="stylesheet" id="custom-css" href="/assets/css/custom-style.css"
        type="text/css" media="all" />
		
		<link rel="stylesheet" href=/plugins/font-awesome/css/font-awesome.min.css />


    <link rel="stylesheet" id="fortawesome-css" href="/assets/fontawesome-5.15.4/css/all.min.css" type="text/css" />


    <script type="text/javascript" src="/assets/js/jquery.min-3.2.1.js" id="jquery-js"></script>
    <script type="text/javascript" src="/assets/js/content-search.js"  id="content-search-js"></script>

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2634092855285462"
     crossorigin="anonymous"></script>

	
    <script>
        

		var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8450bc732b2a86f7e4aec4ebd9fd8252";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();

        
    </script>
    

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7071W80M2K"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-7071W80M2K');
    </script>

</head>


    <div class="page-container">
	
	<div id="sidebar" class="sticky sidebar-nav fade animate-nav" style="width: 170px">
        
            <div class="modal-dialog h-100 sidebar-nav-inner">
                <div class="sidebar-logo border-bottom border-color">
                    
                    <div class="logo overflow-hidden">
                        <a href="https://ai123.869hr.uk/" class="logo-expanded">
                            <img src="/assets/images/bt8-expand-light.png" height="40" class="logo-light"
                                alt="AI123| ai工具网址导航,ai最新产品">
                            <img src="/assets/images/bt8-expand-dark.png" height="40" class="logo-dark d-none"
                                alt="AI123| ai工具网址导航,ai最新产品">
                        </a>
                        <a href="https://ai123.869hr.uk/" class="logo-collapsed">
                            <img src="/assets/images/bt.png" height="40" class="logo-light"
                                alt="AI123| ai工具网址导航,ai最新产品">
                            <img src="/assets/images/bt.png" height="40" class="logo-dark d-none"
                                alt="AI123| ai工具网址导航,ai最新产品">
                        </a>
                    </div>
                    
                </div>
                <div class="sidebar-menu flex-fill">
                    <div class="sidebar-scroll">
                        <div class="sidebar-menu-inner">
                            <ul>
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#00834a9dd147b04c5d53d4368cdb0b57" class="smooth">
                                            <i class="fas fa-sun fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>本月热门</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#db0311e7ecfedd24d157f0ceb4a0897f" class="smooth">
                                            <i class="fas fa-star-and-crescent fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>热门网站</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#21b5cbb2c769010fec3ce029a5f8a4a3" class="smooth">
                                            <i class="far fa-star fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>国内热门</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#8310718935e8ec25ce0350de01e3f7dc" class="smooth">
                                            <i class="fas fa-phone fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>对话工具</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#d58e850d9115797306c2edf61ac6ddd8" class="smooth">
                                            <i class="fas fa-newspaper fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>写作</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#2a7418a5f8f1ca4e054364a9300657df" class="smooth">
                                            <i class="fas fa-image fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>图像生成</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#7808a68ee1b34dab43011429a12de19e" class="smooth">
                                            <i class="fas fa-image fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>图像处理</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#6729afc51f5ac49a828812fa0eb0c82f" class="smooth">
                                            <i class="fas fa-video fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>音视频</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#e5ce844860451fff3faf3d8f8894971d" class="smooth">
                                            <i class="fas fa-music fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>音乐生成</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#db53804b7d726967c58fcc8c9ca03d27" class="smooth">
                                            <i class="fas fa-language fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>办公</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#47b7af9547e034d28fe6f6d439968ac8" class="smooth">
                                            <i class="fas fa-copy fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>提示词</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#41282bf95e43c64d579757573a03cdde" class="smooth">
                                            <i class="fas fa-code fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>编程</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#fd71852fd52d5e18ef4f9a252f1eac58" class="smooth">
                                            <i class="fas fa-search fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>AI搜索</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#81b1637fbe47625dbdf2094acd3b6683" class="smooth">
                                            <i class="fas fa-language fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>文本翻译</span>
                                        </a>
                                    </li>
                                    
                                
                                    
                                    <li class="sidebar-item">
                                        <a href="/#2e9ba3fa6e1ed0e9311b3e97f97f9a40" class="smooth">
                                            <i class="fas fa-book fa-lg fa-lg icon-fw icon-lg mr-2"></i>
                                            <span>学习网站</span>
                                        </a>
                                    </li>
                                    
                                
                            </ul>           
                        </div>
                    </div>
                </div>
                <div class="border-top py-2 border-color">
                    <div class="flex-bottom">
                        <ul>
			    <li id="menu-item-212"
                                 class="menu-item menu-item-type-custom menu-item-object-custom menu-item-212 sidebar-item">
                                 <a href="#friendlink" class="smooth">
                                     <i class="fab fa-staylinked icon-fw icon-lg mr-2"></i>
                                     <span>友情链接</span>
                                 </a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>


<div class="flex-fill grid-bg">
    <div class="big-header-banner">
        <div id="header" class="page-header sticky">
            <div class="navbar navbar-expand-md">
                <div class="container-fluid p-0">

                    <a href="" class="navbar-brand d-md-none" title="AI123| ai工具网址导航,ai最新产品">
                        <img src="/assets/images/bt.png" class="logo-light"
                            alt="AI123| ai工具网址导航,ai最新产品">
                        <img src="/assets/images/bt.png" class="logo-dark d-none"
                            alt="AI123| ai工具网址导航,ai最新产品">
                    </a>

                    <div class="collapse navbar-collapse order-2 order-md-1">
                        <div class="header-mini-btn">
                            <label>
                                <input id="mini-button" type="checkbox">
                                <svg viewbox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                                    <path class="line--1" d="M0 40h62c18 0 18-20-17 5L31 55"></path>
                                    <path class="line--2" d="M0 50h80"></path>
                                    <path class="line--3" d="M0 60h62c18 0 18 20-17-5L31 45"></path>
                                </svg>
                            </label>

                        </div>

                        <ul class="navbar-nav site-menu" style="margin-right: 16px;">
                        
			<li >
				<a href="/">
                                    <i class="fa fa-home fa-lg mr-2"></i>
                                    <span>首页</span>
                                </a>
				<ul class="sub-menu">
				
				</ul>
			    </li>
			
			</ul>

                        
                        <div class="rounded-circle weather">
                            <div id="he-plugin-simple" style="display: contents;"></div>
                            <script>WIDGET = {
                                    CONFIG: {
                                        "modules": "01234",
                                        "background": 5,
                                        "tmpColor": "008000",
                                        "tmpSize": 14,
                                        "cityColor": "008000",
                                        "citySize": 14,
                                        "aqiColor": "#008000",
                                        "aqiSize": 14,
                                        "weatherIconSize": 24,
                                        "alertIconSize": 18,
                                        "padding": "10px 10px 10px 10px",
                                        "shadow": "1",
                                        "language": "auto",
                                        "borderRadius": 5,
                                        "fixed": "false",
                                        "vertical": "middle",
                                        "horizontal": "left",
                                        "key": "085791e805a24491b43b06cf58ab31e7"
                                    }
                                }
                            </script>
                            <script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script>
                        </div>
                        
                    </div>

                    <ul class="nav navbar-menu text-xs order-1 order-md-2">
                        
                        
                        <li class="nav-item mr-3 mr-lg-0 d-none d-lg-block">
                            <script>
                                fetch('https://v1.hitokoto.cn')
                                    .then(response => response.json())
                                    .then(data => {
                                    const hitokoto = document.getElementById('hitokoto_text')
                                    hitokoto.href = 'https://hitokoto.cn/?uuid=' + data.uuid
                                    hitokoto.innerText = data.hitokoto
                                    })
                                    .catch(console.error)
                            </script>                           
                            <div id="hitokoto"><a href="#" target="_blank" id="hitokoto_text">疏影横斜水清浅，暗香浮动月黄昏。</a></div>
                        </li>
                        
                        
                        <li class="nav-search ml-3 ml-md-4">
                            <a href="javascript:" data-toggle="modal" data-target="#search-modal"><i
                                    class="iconfont icon-search icon-2x"></i></a>
                        </li>
                        <li class="nav-item d-md-none mobile-menu ml-3 ml-md-4">
                            <a href="javascript:" id="sidebar-switch" data-toggle="modal"
                                data-target="#sidebar"><i class="iconfont icon-classification icon-2x"></i></a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="placeholder" style="height:74px"></div>
    </div>




<body class="page-body boxed-container  io-grey-mode">
    <main role="main" class="flex-shrink-0">
    <div class="container">
        
        <div class="content">
            <style>
    body{
	    background: #f9f9f9;
	}

    h1, h2, h3, h4, h5, h6 {
        margin-top: 1.5rem;
        margin-bottom: 1.5rem;
    }


 
@media (min-width: 1000px) {
  .container, .container-sm {
    max-width: 800px;
  }
}

</style>

<div class="featured-post-content">

    <a href="/digest/" class="featured-post-title">
       AI 文摘
    </a>

</div>

<section class="blog-single">
  <div class="container">
    <div class="row">

      <div class="col-lg-12 order-1 order-lg-2">
        <article class="single-blog">
          <p class="title">多模态的大一统之路</p>
            <br/>
          <ul class="meta">
            <li>
              By <a href=https://ai123.869hr.uk/about>AI123</a>
            </li>
            <li>
              <i class="fa fa-clock-o"></i>
              August 3, 2023 - 2 min read
            </li>
          </ul>

          <div class="_1NCGf">
              <img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8oyYUWNHcbBvygAaznD85lknicSa3gRKHqhV2fzzTG6ib4quZSV7P17Dg/640?wx_fmt=png" width="640" >
          </div>
            <br>
            <br>
            <br>
          
          <div class="single-blog-content">
            <p>作者： AINLP  来源： <a href="https://mp.weixin.qq.com/s/hS8dvMFCw38W67Zom3-MJQ">AINLP</a></p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_jpg/nW2ZPfuYqSJuK8UUBxdZXj1c20hUg374YPgXibgDGytAy87YxvVk4WCRFWrdKJPshStrlPJp4vGEGUQodxt7ibOw/640?wx_fmt=jpeg" alt=""></p>
<p>作者：<a href="">aaronxic个人主页</a></p>
<p>原文地址：https://zhuanlan.zhihu.com/p/643969218</p>
<h4 id="开篇">开篇</h4>
<p>前面几篇我们已经了解了transformer是如何应用在LLM领域中，从这一篇开始我们进入多模态的领域，看看多模态是如何通过transformer架构逐渐走向大一统的。</p>
<p><em>PS: 长文预警，本篇约2w字，关注&amp;收藏后电脑上阅读体验更加哦~</em> (^_^)</p>
<p>提纲如下，共5个章节</p>
<ul>
<li>
<p>首先介绍了Vision Transformer的入门知识和相关的应用。包括了ViT(2020.10)，ViT-22B(2023.02)，Swin Transformer(2021.08)，MAE(2021.11)，BEiT(2021.06)，BEiTv2(2022.08)，TimeSFormer(2021.02)，BEVFormer(2022.03)。</p>
</li>
<li>
<p>接着介绍了多模态任务、训练评测数据集和评测方法。包括了Video Action Recognition任务，Image Text Retrieval任务，Image Caption任务，Visual QA任务，Visual Reasoning任务，Visual Entailment任务。</p>
</li>
<li>
<p>开始介绍多模态大一统的Stage1，模块独立。从TE，VE和MI三个模块的复杂度关系入手，列举了4种类型的网络结构，包括了SCAN(2018.03)，CLIP(2021.02)，FLIP(2022.12)，ViLT(2021.02)，ALBEF(2021.07)，CoCa(2022.08)。</p>
</li>
<li>
<p>继续介绍多模态大一统的Stage2，模块共享。VLMO(2021.11)开启了TE，VE和MI三个模块共享transformer block的先例，启发了后续BLIP(2022.01)，BEiTv3(2022.08)和BLIP2(2023.01)等工作</p>
</li>
<li>
<p>最后介绍了多模态大一统的Stage3，范式统一。这是一个仍然蓬勃发展的方向，以个人见解列举了Pixel2seq(2021.09)和Unified-IO(2022.06)的范式统一方法。</p>
</li>
</ul>
<h4 id="vision-transformer入门">Vision Transformer入门</h4>
<p>多模态统一的第一步是架构统一，因此如何将transformer应用在传统的CV任务里面变得尤为重要，下面就介绍transformer是如何替代CNN充当视觉任务的骨干网络。</p>
<h4 id="vit">ViT</h4>
<p>回想在NLP里面，text通过tokenization的过程变成了token序列，那么对应vision里面的tokenization过程是什么呢？有一种简单直观的想法，切分patch，过程如下</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8IyITLJ9BpHrlbiagoYf8jTqkEvBMCWFBUmEszrKJvaHNHkgddicY2ianw/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>输入的图片，切分成像素的patch，因此变成了的grid，由于原始输入是通道为3的RGB图片，因此每个格点是维度的feature</p>
</li>
<li>
<p>数学化表达上述过程，就是假设图片，沿着长和宽切分成个的patch，其中，则最终得到的输入为</p>
</li>
<li>
<p>这样就类比于NLP中的序列长度了</p>
</li>
<li>
<p>这里切分既可以通过对原始像素做reshape和transpose实现，也可以用且的卷积实现，同时引入了可学习的映射过程</p>
<p>Conv2d(3, 768, kernel_size=(16, 16), stride=(16, 16))</p>
</li>
</ul>
<p>CLS token: 此外为了方便下游做全局任务(例如图像分类)，添加可学习的 CLS token
，放在网络最前面，因此序列长度为。用 CLS token
对应的输出做全局信息获取做下游分类任务即可。</p>
<p>PE: 由于transformer本身对位置无感，因此需要把位置信息encode进行，ViT引入了可学习的绝对位置编码(learnable absolute PE)。如上图示例中划分成了9个patch，再加上 CLS token
，因此可学的位置编码有10个</p>
<p>网络结构：所有patch token之间信息相互可见，因此使用了标准的pre-norm的encoder结构</p>
<h4 id="vit-22b">ViT-22B</h4>
<p>NLP那边网络可以scale到175B的大小，那么ViT是否也能轻松scale呢？貌似看起来也不是那么容易。ViT-22B 中做了3个改动才成功把网络放大到22B，如下所示</p>
<ul>
<li>
<p>对query和key做了额外的前置LayerNorm，否则导致训练不稳定。下图绿色就加了前置LayerNorm的，红色就是没有加前置LayerNorm的</p>
</li>
<li>
<p>对MHA和FFN做了并行化改造，这样并行度更高，减少训练耗时</p>
</li>
<li>
<p>移除了input projection和LayerNorm后面的bias</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8Q8nPooWOBvSkRBjAI65Cr1z3FicTEVDCGBQ9599vLlrHfBqqpQiaM5Mg/640?wx_fmt=png" alt=""></p>
<p>改进后的transformer block如下所示</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8kQ9nWYgSuG5OdgQSoI1U90o0AWO1iaoOWL7zw8wzNPRhJzejibOtUxYQ/640?wx_fmt=png" alt=""></p>
<p>完整的参数量对比如下所示</p>
<p>名称hidden size(D)MLP size(M)Layers(L)#Param</p>
<p>ViT-Base
768
3072
12
86M</p>
<p>ViT-Large
1024
4096
24
307M</p>
<p>ViT-Huge
1280
5120
32
632M</p>
<p>ViT-G
1664
8192
16
1.8B</p>
<p>ViT-e
1792
15360
16
3.9B</p>
<p>ViT-22B
6144
24576
48
21.7B</p>
<p>参数计算公式可参考本系列《初探LLM基座模型》文章内容</p>
<p><em>PS: ViT-G和ViT-e分别来自论文1和论文2</em></p>
<h4 id="swin-transformer">Swin Transformer</h4>
<p>从上文可知ViT的序列长度是跟分辨率大小成正比的，而transformer结构的计算复杂度又跟序列长度呈平方关系，因此当下游任务的分辨率线性增长时，ViT的计算复杂度呈平方量级增长，计算效率显著下降。</p>
<p>如何解耦分辨率和计算量，成了Swin Transformer需要解决的问题。具体来说通过3个过程实现</p>
<ul>
<li>
<p>窗口内信息交换。划分窗口，在窗口内做self-attention，实现完全信息交换</p>
</li>
<li>
<p>相邻窗口间信息交换。通过shift方式实现相邻窗口的信息交换。</p>
</li>
<li>
<p>远距离窗口间信息交换。对窗口做合并，扩大窗口覆盖原始像素面积，使得相距更远的窗口可以交换信息。</p>
</li>
</ul>
<p>下面详细介绍Swin Transformer的处理过程。</p>
<p>网络总览</p>
<p>借用这篇文章的图，网络整体分成了4个stage，每个stage由若干block组成，block数量分别是2-2-6-2</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8nnZSicGx7QsVUlsfyYaL6ichxFItxAO7SYZKERKFZic5AVn2vQraM4NVg/640?wx_fmt=png" alt=""></p>
<p>窗口内信息交换</p>
<p>首先对原始的输入图片做的patch划分，映射feature维度为，因此经过第一层之后tensor的尺寸为</p>
<p>不同于ViT的直接把的序列直接输入transformer，Swin的对此做进一步窗口划分，大小为，因此可以得到个大小的patch窗口，输出tensor尺寸为</p>
<p>这样有组的序列独立做self-attention，实现了patch窗口内的信息交换，做完之后重新reshape回到输入的大小</p>
<p>下图展示的是个patch为1个窗口的例子，实际中是个patch为1个窗口</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8kZIPibfyIeicUDBlLHFveRKCDicB16gGCibcVvCE8ocmPyZbvlx3QVutVw/640?wx_fmt=png" alt=""></p>
<p>从《初探LLM基座模型》中我们知道，ViT的计算量公式为</p>
<p>因此的计算量为</p>
<p>将输入切成了若干个的patch窗口，因此可以得到计算量为</p>
<p>可见计算复杂度从的降成了的</p>
<p>相邻窗口间信息交换</p>
<p>上述结构确实降低了计算量，但是也造成了窗口之间的信息割裂，不同窗口间的像素永远无法做信息交互。一种解决方法就是将patch窗口划分方式进行shift，如下所示分别朝右和朝下循环位移半个窗口，形成了9个新窗口。</p>
<p>经过这样的操作，对于P点像素，在Layer L中跟左上角窗口内的像素做信息交换，到了Layer L+1之后可以跟0号窗口内的像素做信息交互，不会出现信息闭塞的问题。</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8tUV6BNFy70yRSmbQaqmpHOzDt9Wglggz0f3XJWHK6O5kjzphY887UA/640?wx_fmt=png" alt=""></p>
<p>但不难发现，如果按照naive的方式实现上述流程，从4个窗口变成了9个窗口，会增加了额外的计算复杂度。因此一种解决方案就是把边角的窗口拼接在一起，用mask掩码保证信息隔离跟原来拼接前完全等效。具体来说，把(0), (1, 2), (3, 6)和(4, 5, 7, 8)通过shift操作拼接在一起，形成4个新窗口</p>
<pre><code>shift_size = window_size // 2  
# shift_windows: (C, H, W)   
torch.roll(shift_windows, shifts=(shift_size, shift_size), dims=(1, 2)   
</code></pre>
<p>如下所示</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8rzVw22NShXKf0LvebOxsqiaMxibmJ1q0xIUjhIKgO1BjVHibpvbiajmmhQ/640?wx_fmt=png" alt=""></p>
<p>掩码添加非常巧妙，黄色代表mask掉，即禁止信息交互。大家可以自行推导一下</p>
<ul>
<li>
<p>Hint1：把每个window内的像素从左到右，从上到下展开成长向量vector，代表窗口掩码的行和列下标</p>
</li>
<li>
<p>Hint2：保证每个数字内像素点可以相互交互，不同数字间的像素点要被黄色mask掉</p>
</li>
</ul>
<p>注意最后做完masked-attention之后，调用 torch.roll
循环位移回来即可</p>
<p>远距离窗口间信息交换</p>
<p>只有上述窗口内信息交换和相邻窗口信息交换还是不够，因为没法实现长距离的信息交换，因此类似CNN堆叠stage增大感受野，Swin也引入了多stage概念，每个stage中间会进行window的合并和特征维度的扩增，代码中叫Merging模块</p>
<p>这个过程跟spatial_to_depth比较像，spatial_resolutin减半，feature增加</p>
<pre><code># input_feature: (1, 56, 56, 96)  
# (1, 56, 56, 96) -&gt; (1, 28, 28, 96)*4 -&gt; (1, 28, 28, 384)  
input_feature_0 = input_feature[:, 0::2, 0::2, :]  
input_feature_1 = input_feature[:, 1::2, 0::2, :]  
input_feature_2 = input_feature[:, 0::2, 1::2, :]  
input_feature_3 = input_feature[:, 1::2, 1::2, :]  
input_feature = torch.cat([input_feature_0, input_feature_1, input_feature_2, input_feature_3], -1)  
</code></pre>
<p>至此，Swin Transformer设计了窗口内，相邻窗口，远距离窗口的3种信息交换过程，实现了计算量大幅下降的同时，保证信息能自由流动</p>
<h4 id="mae">MAE</h4>
<p>对Vision Transformer有了基本认识之后，下面介绍几个比较重要的应用，扩展对Vision Transformer应用案例的认知。</p>
<p>其中一个是使用MAE(Masked Autoencoders)做无监督训练。如下所示</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha84b8YWxqaYZ13HYK84ib6fIGCYick9gFc0LdN2icQ6bJTyTXWmtlWPXncw/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>MAE把问题建模成类似BERT里面的完形填空，将patch看作视觉完形填空的对象</p>
</li>
<li>
<p>整体架构是encoder-decoder的transformer结构，但是注意decoder没有cross-attention</p>
</li>
<li>
<p>encoder部分。随机把高达75%的patch给mask掉，将剩下patch喂入ViT-like结构的encoder里面</p>
</li>
<li>
<p>decoder部分。 可学习的[MASK] token
代表前面被mask掉的patch的编码，拼接上encoder对剩余patch的编码，重新排序后喂入decoder做full-self-attention，最后decoder的输出就是重建每个patch的像素值，具体来说是个值</p>
</li>
<li>
<p>最后将重建的像素和输入图像做均方误差loss监督即可</p>
</li>
</ul>
<p>MAE的其中一个亮点是训练比较快，原因是</p>
<ul>
<li>
<p>encoder部分只把mask之后剩余的patch喂入网络，因此序列长度减少到原始数量的1/4左右</p>
</li>
<li>
<p>decoder虽然需要所有位置的patch输入，但是由于大小比encoder小一个数量级，因此使用起来也很高效</p>
</li>
</ul>
<h4 id="beit">BEiT</h4>
<p>不同于MAE把像素级的原始patch作为重建对象，BEiT把抽象的vision token作为重建的对象，如下所示</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8QzZ0UHY014qxiaWGSjt4K3OkMZScC3PY9rcPXPJ9xsDT9wtfxrFEy9A/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>重建目标vision token直接来自DALL-E论文开源的码本，该码本是通过dVAE的方式重建学习而来。dVAE的训练方式将在下一篇《AIGC组成原理》中做展开介绍</p>
</li>
<li>
<p>除了重建目标不同，BEiT的网络只由Encoder组成，此外mask掉的patch直接用可学习的 [M] token
替代</p>
</li>
</ul>
<p><em>PS: BEiTv2使用了VQ-VAE的方式重建teacher的特征(例如CLIP)，最后得到每个patch的vision tokens码本。VQ-VAE的训练方式将在下一篇《AIGC组成原理》中做展开介绍</em></p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8kMyFMyZlN9Sicjg7XaQRVY09oNenETNg5YNZTDvfpyxI3NBLgRno6Aw/640?wx_fmt=png" alt=""></p>
<h4 id="timesformer">TimeSFormer</h4>
<p>除了使用Vision Transformer做无监督训练，还有使用Vision Transformer做视频动作分类。顾名思义，就是给定一段视频片段，要求算法返回视频包含的动作类别。这里核心要解决的是在计算复杂度受限的情况下，如何在空间维度和时间维度分配transformer的注意力计算。</p>
<p>TimeSFormer对此作了多种拆解的探究，如下所示</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8PEM7PW9hXM4G7CLteTTBlia4V8ZHUpsm04Bib1l37G7SqrFz2OOdXBQA/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>Space Attention (S)。只保留空间的注意力，相当于单帧做，不考虑时序间的信息交流。对应下图(S)列，红色patch就是蓝色patch的注意力范围</p>
</li>
<li>
<p>Joint Space-Time Attention (ST)。空间和时间进行完整的注意力，相当于每一个patch都能获取到空间和时间的所有信息。对应下图(ST)列，红色patch就是蓝色patch的注意力范围</p>
</li>
<li>
<p>Divided Space-Time Attention (T+S)。空间维度自己做注意力，时间维度自己做注意力。对应下图(T+S)列，绿色patch就是蓝色patch在时间维度的注意力范围，红色patch就是蓝色patch在空间维度注意力范围，这里两个独立的注意力模块</p>
</li>
<li>
<p>Sparse Local Global Attention (L+G)。按照空间距离使用不同的注意力模块。对应下图(L+G)列，粉色patch就是蓝色patch在距离为0的注意力范围，黄色patch就是蓝色patch在距离为1的注意力范围，紫色patch就是蓝色patch在距离为3的注意力范围，这里有3个独立的注意力模块</p>
</li>
<li>
<p>Axial Attention (T+W+H)。按照特征维度使用不同的注意力模块。对应下图(T+W+H)列，绿色patch就是蓝色patch在T维度的注意力范围，黄色patch就是蓝色patch在W维度的注意力范围，紫色patch就是蓝色patch在H维度的注意力范围，这里有3个独立的注意力模块</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8CUerFUMNLGJXyS2VPJTH7ZjIsJf298RzJ5IiaWpb000kziaTOlDJThGw/640?wx_fmt=png" alt=""></p>
<p>最后TimeSFormer发现T+S效果最好</p>
<h4 id="bevformer">BEVFormer</h4>
<p>作为Vision Transformer入门的最后一部分，我们来看个不一样的例子，这就是几乎快成为自动驾驶标配的BEVFormer网络结构。核心知识点如下</p>
<ul>
<li>
<p>BEV就是BirdEye View的缩写，即从上往下看的平面俯视图。</p>
</li>
<li>
<p>整体使用的是encoder-decoder架构，其中decoder包含cross-attention</p>
</li>
<li>
<p>encoder部分。BEVFormer的视觉主干并没有使用ViT进行feature抽取，但是从原理上可以将CNN替换成ViT或者Swin Transformer</p>
</li>
<li>
<p>decoder部分。BEVFormer本质上是借助多视角的相机信息做隐式的多视几何(Multiview Geometry)，通过learnable query和cross-attention机制把图片空间的feature整合到了BEV空间中</p>
</li>
</ul>
<p>下面详细说说decoder计算过程(简单起见忽略时间维度)，如下所示</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8KymiayAJjJjNTEKPAD6HxiaPzyib3OibAu30iaNIDKm3aZEnMhElx6YBGSA/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>前面encoder已经得到了每个camera不同网络深度的feature，简化表达为</p>
</li>
<li>
<p>在BEV坐标系下对车辆周边空间做网格划分，其中代表空间中的一点，每个点对应一个learnable query，即</p>
</li>
<li>
<p>考察每个对应的encoder输出</p>
<ul>
<li>
<p>通过相机外参和内参，把映射到各个相机的像素平面</p>
</li>
<li>
<p>利用Deformable Attention机制，在点附近aggregate encoder的特征输出，得到对应的feature输出，即</p>
</li>
<li>
<p>对按网格坐标进行排列拼接，形成最终的BEV网格feature，输出到下游各个head任务</p>
</li>
</ul>
</li>
</ul>
<p>这里Deformable Attention的核心过程如下</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8Su3fjiaia3ySYmpgCrHhIWeTKhLFnGPcNJDibicGMmjHWbCDQnrLhTibHjA/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>每个query通过linear层映射编码出一组offset和一组weight</p>
</li>
<li>
<p>每个offset叠加前面的像素得到最终的像素位置，索引该位置的feature，跟另外的一组weight做加权乘累加，得到这个query的最终feature</p>
</li>
</ul>
<h4 id="小结">小结</h4>
<p>本节介绍了Transformer是如何应用在Vision中，并且介绍了优化方法和若干周边应用</p>
<ul>
<li>
<p>ViT。开创了vision transformer的先河，本质上是对图片切分patch，转换成patch token序列，然后用处理text token的方式处理patch token即可</p>
</li>
<li>
<p>Swin Transformer。为了解决原始的ViT的计算复杂度跟输入图片分辨率呈平方关系的问题，通过设计窗口内，相邻窗口，远距离窗口的3种信息交换过程，实现了计算量大幅下降的同时，保证信息能自由流动</p>
</li>
<li>
<p>无监督应用。类似于BERT做完形填空，vision里面的MAE和BEiT也尝试做视觉完形填空，前者尝试重建raw pixel，后者尝试重建抽象的vision token</p>
</li>
<li>
<p>视频动作分类应用。使用Vision Transformer做视频动作分类，核心要解决的是在计算复杂度受限的情况下，如何在空间维度和时间维度分配transformer的注意力计算。TimeSFormer尝试了多种拆解方法，最后发现空间和时间分开的方法效果最好。</p>
</li>
<li>
<p>自动驾驶应用。最后我们简单介绍了BEVFormer，一种使用cross-attention机制来提取特征完成下游视觉任务的特殊例子</p>
</li>
</ul>
<h4 id="多模态任务和评测方法">多模态任务和评测方法</h4>
<p>有了Vision Transformer之后，视觉和文本至少在形式上可以在同一个空间中表达了，这给他们的直接交互提供了极大的便利，于是多模态的各种工作就雨后春笋般出现。</p>
<p>多模态范围非常宽泛，个人认为但凡涉及到多种模态(图片，文字，声音，视频，激光雷达，毫米波雷达等)的输入，以及单种或者多种模态输出的过程，都可以理解为多模态。</p>
<p>在正式介绍多模态的相关算法之前，我们先捋一下多模态的任务都有哪些，以及相关的训练测试集和评测方法是什么。这里不求大而全的多模态任务罗列，更多的是把后续多模态论文中涉及到的多模态任务提前解释和介绍一下</p>
<h4 id="video-action-recognition">Video Action Recognition</h4>
<p>视频动作分类，给一段15秒内的短视频，要求算法识别出其中的动作类别。常用的数据集有</p>
<ul>
<li>
<p>UCF-101。从YouTube搜集的101个动作类别视频，一共有13320个视频片段，分为25组，每组4-7个动作，每组有共同特征，例如相似的背景，相似的视角等。每段视频10秒左右。</p>
</li>
<li>
<p>HMDB-51。从YouTube和Google搜集的51个动作类别视频，一共6849个视频片段，同样也是短视频</p>
</li>
<li>
<p>Moments in Time。339个动作类别，一共有1百万段长度为3秒的视频片段，平均每个动作有1k个以上视频片段</p>
</li>
<li>
<p>Kinetics400/600/700。从YouTube搜集的400/600/700个动作类别视频，每个动作包含400/600/700个视频片段，每段视频长度为10秒左右</p>
</li>
</ul>
<p>指标跟ImageNet类似，多分类下的Top1或者Top5的accuracy</p>
<h4 id="image-text-retrival">Image Text Retrival</h4>
<p>图文检索任务</p>
<ul>
<li>
<p>图搜文。给定一张图片和若干段文字描述，要求算法返回最匹配的文字描述</p>
</li>
<li>
<p>文搜图。给定一段文字和若干张图片，要求算法返回最匹配的图片</p>
</li>
</ul>
<p>常用的数据集有</p>
<ul>
<li>
<p>Flickr30K。包含了31K张来自Flickr的人工精标图文数据集，每张图片有5个文字描述</p>
</li>
<li>
<p>MS-COCO。包含了113k人工精标的图文数据，每张图片有至少一个文字描述，质量很高</p>
</li>
</ul>
<p>指标计算跟检索排序类似，给定一张图片和海量的候选文字描述，算法返回排序后的文字描述，然后计算Recall@k，就是返回结果里面前K个是否包含正确结果。</p>
<h4 id="image-caption">Image Caption</h4>
<p>生成图片描述任务，给定图片，要求算法生成文字描述。图文检索任务的数据可以直接拿来用，除此之外还有很多网络爬取的图文数据。</p>
<ul>
<li>
<p>Visual Genome (VG)。最早是李飞飞组提出的，原始数据集规模很大，但是后人认为其中的object标注过于杂乱，存在命名模糊和bounding box重叠的问题。所以一般使用VG150的精简版，数据质量更高，包含108K张图片，5.41M段文字描述</p>
</li>
<li>
<p>CC12M。CC12M来自Google的web数据集，包含URL，自行通过爬虫下载链接。一共有12M，里面存在大量noise，所以需要经过过滤。</p>
</li>
<li>
<p>SBU。来自Flickr的数据集，约800K对图文数据</p>
</li>
<li>
<p>LAION400M。来自LAION非营利性组织，来自Common Crawl原始数据，使用了CLIP做过滤，把相似度小于0.3的过滤了。总共400M对图文数据</p>
</li>
</ul>
<p>指标计算比较启发式，本质上是计算两个sequence的相似度，常用的指标有CIDEr，BLEU，ROUGE和METEOR，其中使用CIDEr居多</p>
<h4 id="visual-qa">Visual QA</h4>
<p>看图回答问题，给定图片和提问，要求算法回答问题，一般分成闭集QA和开集QA，前者是多分类任务，后者是文字生成任务。</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8VkHCTyFNrMSnUicgWlUsHmkriaCvV1xw9iamuFOG88yickp6LRkZdpLGpA/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>Closed QA，闭集QA，看成多分类任务。常用数据集为VisDial。数据集本身有多个问答，一般转换为二分类问题</p>
</li>
<li>
<p>Open QA，开集QA，看成文字生成任务。常用数据集为VQAv2。往往回答很简短，所以直接根据算法返回的结果做字符串匹配，完全匹配才算正确。注意VQAv2也可以变成closed的QA，就是把多选的挑出来，然后变成3129类的分类问题。</p>
</li>
</ul>
<h4 id="visual-reasoning">Visual Reasoning</h4>
<p>视觉推理任务。给定图片和文字描述，要求算法判断文字是否匹配，常用数据集为NLVR2。是给了2张图片+文字描述，判断描述是否和图片匹配，一共包含92K个问题。</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8qniaYgZDq5xLDMzfYibHg9iaR61mGoNuCmoaico97I0Rh16yujXPTN7XLw/640?wx_fmt=png" alt=""></p>
<p>二分类问题，指标使用accuracy</p>
<h4 id="visual-entailment">Visual Entailment</h4>
<p>视觉蕴含判断任务。图片作为premise，文字是Hypothesis，要求算法返回蕴含、对立或者中立(无法判断)，属于三分类问题。常用的数据为SNLI-VE，包含30K张图片</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8D7wibo4UxQUNglfp9k0DwvribZebVqTdDUCaJia9ogxGqRaQzzMicnE3DA/640?wx_fmt=png" alt=""></p>
<p>三分类问题，指标使用accuracy。</p>
<h4 id="小结-1">小结</h4>
<p>汇总以上的信息，总结成表格，方便查询</p>
<p>任务名称简称数据集名称数据集大小指标计算</p>
<p>Video Action Recognition
VAR
UCF-101
101类共13K个视频片段
Accuracy</p>
<p>HMDB-51
51类共7K个视频片段
Accuracy</p>
<p>Moments in Time
339类共1M个视频片段
Accuracy</p>
<p>Kinetics400
400类且每类400个视频片段
Accuracy</p>
<p>Kinetics600
600类且每类600个视频片段
Accuracy</p>
<p>Kinetics700
700类且每类700个视频片段
Accuracy</p>
<p>Image Text Retrival
Retrival任务
Flickr30K
31K张图片，155K文字描述
R@1</p>
<p>MS-COCO
113K张图片，567K文字描述
R@1</p>
<p>Image Caption
Caption任务
Visual Genome
108K图片，5.41M文字描述
CIDEr</p>
<p>CC3M
3.01M对图片和文字描述
CIDEr</p>
<p>SBU
867K对图片和文字描述
CIDEr</p>
<p>LAION400M
400M图片
CIDEr</p>
<p>Visual QA
VQA
VQAv2
265K张图片
Accuracy</p>
<p>VisDial
130K图片
Accuracy</p>
<p>Visual Reasoning
VR
NLVR2
92K个问题
Accuracy</p>
<p>Visual Entailment
VE
SNLI-VE
30K张图片
Accuracy</p>
<h4 id="大一统stage1-模块独立">大一统Stage1: 模块独立</h4>
<p>接下来我们正式进入多模态算法部分，重点关注的是图片和文字的模态交互。我们可以简单的抽象出三个模块</p>
<ul>
<li>
<p>Textula Embed(TE)。文字特征抽取模块，主要接受文字信息输入，经过主干网络(例如LSTM/GRU/Transformer等)变成抽象的文字特征</p>
</li>
<li>
<p>Visual Embed(VE)。图特征抽取模块，主要接受图片信息输入，经过主干网络(SIFT/CNN/ViT)变成抽象的图片特征</p>
</li>
<li>
<p>Modality Interaction (MI)。多模态交互模块，接受文字特征和图片特征，对其进行信息融合，完成下游需要的任务。</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8bMTXAaoJVeDWyK7g1YTqBecFhsXem65NHxahsuqic7h7j0WH32cibMag/640?wx_fmt=png" alt=""></p>
<p>多模态的早期发展阶段，TE, VE和MI的3个模块是相互独立，没有权值共享。按照3个模块之间复杂程度的相对关系，可以分出上述的(a)-(b)-(c)-(d)共4类网络架构设计，</p>
<p>类别典型方法方法特征</p>
<p>(a) VE &gt; TE &gt; MI
SCAN
早期方法，图片比文字部分复杂，但是由于MI比较小，往往效果不太好</p>
<p>(b) VE = TE &gt; MI
CLIP/FLIP
图片和文字一样复杂，但是由于MI比较小，在稍微复杂的Visual QA，Visual Reasoning等任务上表现就没那么好</p>
<p>(c) VE &gt; MI &gt; TE
ALBEF/CoCa
SOTA方法，图片比文字部分复杂，并且MI足够复杂可以处理下游复杂任务，效果一般不错</p>
<p>(d) MI &gt; VE = TE
ViLT
图片和文字一样复杂，都比较简单，虽然MI足够复杂，但是图片部分脑容量不够导致效果并不是SOTA</p>
<h4 id="scan">SCAN</h4>
<p>多模态发展过程中，TE和VE的骨干网络一直在不断变化。在ViT完全统治VE之前，一直用物体检测的pipeline来抽取各个物体的框和特征，SCAN就是这一类方法的代表，如下所示</p>
<ul>
<li>
<p>VE部分使用Fast R-CNN作为bottom-up的目标检测器，把所有个物体检测出来并且ROI Pool得到对应的特征，其中</p>
</li>
<li>
<p>TE部分对个单词做特征抽取，得到，其中</p>
</li>
<li>
<p>MI部分</p>
<ul>
<li>
<p>针对这两组特征做了复杂的手工设计的加权方式，最终得到融合后相似度</p>
</li>
<li>
<p>使用Log- SumExp pooling得到最终图片和文字的整体相似度，接着可以做正负样本监督</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8aLENSJhNfarRxkYw6WZUfU9EveQJB5uv6ibTrOv680uCxyAdPgc9rCQ/640?wx_fmt=png" alt=""></p>
<p>作为早期工作的代表，SCAN有以下的局限性</p>
<ul>
<li>
<p>VE部分计算复杂，一般是提前抽取好feature，这样数据增广等技巧就受到阻碍</p>
</li>
<li>
<p>MI部分人工设计公式，复杂且迁移性差，inductive bias过强</p>
</li>
</ul>
<h4 id="clip">CLIP</h4>
<p>OpenAI的CLIP作为(b)类别的代表，对TE和VE一视同仁，MI部分用简单的Contrastive Loss，最后在图片分类任务上效果拔群，影响力巨大。如下所示</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8icoezYBZgASwudxO9zX1niassCeZZVXsoGU5icc9T1qq0wokicoHdfBJicg/640?wx_fmt=png" alt=""></p>
<p>Pre-train</p>
<p>预训练使用Contrastive Loss，具体如下</p>
<ul>
<li>
<p>TE使用带mask的Transformer，方便在encoder-decoder架构和decoder-only架构间切换，抽取得到文本的全局特征</p>
</li>
<li>
<p>VE使用Resnet或者ViT网络结构，得到图片的全局特征</p>
</li>
<li>
<p>MI部分把同一对的text-image看成正样本，其余为负样本，做对比学习</p>
</li>
</ul>
<p>对比学习一般会逐行和逐列分别求一次softmax+cross-entropy，对角线元素为正样本，非对角线元素为负样本，最终除以2取平均。代码更加清晰，如下所示</p>
<pre><code># image_encoder - ResNet or Vision Transformer   
# text_encoder - CBOW or Text Transformer   
# I[n, h, w, c] - minibatch of aligned images  
# T[n, l] - minibatch of aligned texts  
# W_i[d_i, d_e] - learned proj of image to embed   
# W_t[d_t, d_e] - learned proj of text to embed   
# t - learned temperature parameter  
  
# extract feature representations of each modality   
I_f = image_encoder(I) #[n, d_i]   
T_f = text_encoder(T)  #[n, d_t]  
  
# joint multimodal embedding [n, d_e]   
I_e = l2_normalize(np.dot(I_f, W_i), axis=1)   
T_e = l2_normalize(np.dot(T_f, W_t), axis=1)  
  
# scaled pairwise cosine similarities [n, n]   
logits = np.dot(I_e, T_e.T) * np.exp(t)  
  
# symmetric loss function   
labels = np.arange(n)  
loss_i = cross_entropy_loss(logits, labels, axis=0)   
loss_t = cross_entropy_loss(logits, labels, axis=1)  
loss = (loss_i + loss_t)/2  
</code></pre>
<p>这里值得注意的是温度系数 np.exp(t)
，其中不是固定参数，而是可学习的值，同时正好也符合温度系数的值域。OpenAI说这样设置效果更好，也省去人工调参。</p>
<p>此外OpenAI还是用了闭源的经过清洗后的多达400M的数据集，训练代码本身也是闭源的，这也是有后续OpenCLIP等工作的原因。</p>
<p>Zero-shot Predition</p>
<p>在做下游的分类任务的时候，完全可以做zero-shot，text部分有很多模板选择，例如 a photo of {}
等，最后效果大杀四方，并且ViT的效果更好一点</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8FFhNUN6mahCL8ATR6hiayjsHoPiaXALPu4lgEd3fib6lib0ZVRW9I932Lg/640?wx_fmt=png" alt=""></p>
<p>局限性</p>
<ul>
<li>
<p>CLIP在图像分类上效果很好，但是直接使用在更复杂的VQA/VR/VE上效果不佳</p>
</li>
<li>
<p>训练昂贵，需要上千卡天的训练总时间(12 days on 256 V100)</p>
</li>
</ul>
<h4 id="flip">FLIP</h4>
<p>FLIP出发点就是为了解决CLIP训练昂贵的问题，简单理解为Fast版本的CLIP，改进点为</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8CcsBoZ83t9DMic6rIkGZUbxQowtT9xurfPjpm8TUia7OlWdVKIyB64eg/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>MAE里面编码器部分会对原始输入的图片patch做随机mask，比例高达75%</p>
</li>
<li>
<p>只将剩余的patch喂入Vision Encoder(VE)网络</p>
</li>
<li>
<p>这样VE部计算量能降低为原来的，于是训练更加便宜了</p>
</li>
</ul>
<p>最后FLIP中还探究了一下scaling情况，发现模型和数据增大都能继续涨点，但是训练更长epoch没有用</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8LmygITPrLQ9e8ib0tNL6AnWRsp35kULcwJFUxOfhRLqRmxgQRfXj3nA/640?wx_fmt=png" alt=""></p>
<h4 id="vilt">ViLT</h4>
<p>(c)类方法虽然是SOTA，但是很多想法都受到(d)类的代表作ViLT启发，因此在介绍SOTA之前，我们先详细看看(d)类的ViLT是怎么做的。</p>
<p>本节开头的VE, TE和MI的分类方法就是来源于ViLT，ViLT的出发点是把VE彻底换成简单的patch projection模块，借鉴了ViT的思维，如下所示</p>
<ul>
<li>
<p>Region Feature。就是传统的CNN backbond+Det head的方式，本质做检测，然后用ROI Align把对应的feature抽出来作为vision token，计算量比较大</p>
</li>
<li>
<p>Grid Feature。只过CNN backbond，把最后的feature作为vision token，计算量也很大</p>
</li>
<li>
<p>Patch Projection。受到ViT启发，上来就过个简单的conv把的像素区域变成一个patch，然后就直接作为vision token，这样推理速度奇快无比</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8nE81HkBhxicIDzODzwQeIiaZ5I8qVOhq5tUVeXiag266VzPJDPGjHXAgA/640?wx_fmt=png" alt=""></p>
<p>网络结构</p>
<p>整体网络架构图如下所示，典型(d)类没跑了</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8oyYUWNHcbBvygAaznD85lknicSa3gRKHqhV2fzzTG6ib4quZSV7P17Dg/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>跟ViT非常像，是个encoder结构。Text经过embedding之后是，Image经过embedding之后是。Text和Image前面各有一个 CLS token
，因此总的输入尺寸是</p>
</li>
<li>
<p>注意这里的PE(Position Encoding)有两部分</p>
<ul>
<li>
<p>首先是0和1分别编码text部分和image部分</p>
</li>
<li>
<p>其次是在text内和image内的常规的位置编码</p>
</li>
</ul>
</li>
</ul>
<p>Loss设计</p>
<p>训练loss相对比较复杂，得好好说说，包含3个</p>
<ul>
<li>
<p>Image Text Matching (ITM)</p>
<ul>
<li>
<p>类似于constrastive los，从text的CLS token
出来</p>
</li>
<li>
<p>正样本是配对图片，负样本是把image替换成其他图片</p>
</li>
<li>
<p>对图片使用RandAugment做增广，去掉了color jitter和crop的aug，以防出现图文不匹配情况</p>
</li>
</ul>
</li>
<li>
<p>Word Patch Alignment (WPA)</p>
<ul>
<li>对text subset和image subset做最alignment，具体来说使用优搬运理论进行loss最小化，这里不做进一步展开</li>
</ul>
</li>
<li>
<p>Masked Language Modeling (MLM)</p>
<ul>
<li>
<p>类似BERT的完形填空，不过这里用了Whole Word Masking(WWM)，而不是单个token masing</p>
</li>
<li>
<p>Whole Word Masking的出发点也很直接，就是避免网络通过其他词根推测同一个词的剩余部分，例如 giraffe
拆成了 gi
, #raf
和 ##fe
，通过gi
和##fe
可以推断出 #raf</p>
</li>
</ul>
</li>
</ul>
<p>实验效果</p>
<ul>
<li>跟其他Region Feature和Grid Feature的方法相比还有些距离，但是主要贡献是打开了新思路</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8UibXIliaTEsMP4aKJYKIicRkoYuwKRr43EsKprjrjWhYgajTW4YX0uatw/640?wx_fmt=png" alt=""></p>
<h4 id="albef">ALBEF</h4>
<p>随着ViLT开创了VE使用ViT的先河，很多工作开始涌现，其中ALBEF算是其中的佼佼者。ALBEF尝试解决ViT效果不够好的问题，认为VE部分要足够复杂才行，甚至要比TE更复杂，网络结构如下</p>
<ul>
<li>
<p>容易发现很像BERT，只是把BERT的decoder部分拆成两半，一部分给TE，一部分给MI</p>
</li>
<li>
<p>由于VE有12层，TE只有6层，因此符合VE应该要比TE复杂的insight</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8Oib7vTEHCEuSR7WhI97XsBS5DvvCxTP5tghuibHdLzX98lelLjFGs8hQ/640?wx_fmt=png" alt=""></p>
<p>跟ViLT的loss相比，保留了ITC和MLM，新增Image-Text Matching Loss</p>
<ul>
<li>
<p>ITC(Image-Text Constrastive) Loss就是常见的对比学习的loss</p>
<ul>
<li>
<p>正样本来自于当前配对的image和text的feature</p>
</li>
<li>
<p>负样本来自于两个额外的queue，分别为和(后面会介绍)</p>
</li>
</ul>
</li>
<li>
<p>ITM(Image-Text Matching) Loss 就是图文匹配二分类loss，判断image和text是否为正样本，为了类别均衡，也涉及到正负样本来源问题</p>
<ul>
<li>
<p>正样本来自于当前配对的image和text的feature</p>
</li>
<li>
<p>负样本来自于ITC里面最难的负样本</p>
</li>
</ul>
</li>
<li>
<p>MLM(Masked Language Modeling) Loss 就是类似BERT的完形填空任务，有15%的token被 [MASK]
替换</p>
</li>
</ul>
<p>Momentum Model</p>
<p>本文的另外一个创新点是借鉴了MoCo，维护一个跟上图左侧结构完全一样的镜像网络结构Momentum Model(MM)</p>
<ul>
<li>
<p>MM的但是权值更新不是来自于梯度回传，而是来自于左侧模型的EMA(Exponential Moving Average)</p>
</li>
<li>
<p>MM主要的作用是提供负样本来源，维护大小为65536的text的负样本队列，和大小为65536的image负样本队列</p>
</li>
<li>
<p>当前时刻左侧网络forward完之后，把text和image和分别放到负样本队列和的末尾(当做未来时刻的负样本)，同时从两个队列头取出相同数量的样本作为当前时刻的负样本</p>
</li>
</ul>
<p>此外ALBEF使用了CC12M这个比较大且包含较多噪声的数据集，因此借助MM做了self-training的方式</p>
<ul>
<li>
<p>MM是用EMA更新，所以变化缓慢，比较稳定，可以用作teacher</p>
</li>
<li>
<p>用MM当做teacher，对ITC和MLM做蒸馏，称为Momentum Distillation(MoD)</p>
</li>
<li>
<p>ITM由于已经有hard negative了所以就没有用蒸馏loss</p>
</li>
</ul>
<p>ALBEF也通过可视化验证了MM作为teacher的靠谱程度，如下GT就是原始标签，peeud-target就是MM模型的输出</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8IRbjPKdhoMdJAMdfbhxH0wryZvsW0ckkduxYiaR4EumkpMibVyRM7wFg/640?wx_fmt=png" alt=""></p>
<p>实验结果</p>
<p>在Image Retrival, VQA, VR和VE上均取得了不错的效果</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8G60U3ARcvbm0RvCaQC2VlygF2JbrGolXQq3jl3kGlpyycYrJKc37NQ/640?wx_fmt=png" alt=""></p>
<h4 id="coca">CoCa</h4>
<p>同样作为(c)类方法，CoCa把ALBEF的能力往前推了一大截，主要改进点如下</p>
<ul>
<li>
<p>MI部分换成decoder-only架构，因此不做BERT完形填空任务了，直接做caption生成任务</p>
</li>
<li>
<p>loss只保留了图文Constrastive Loss (Co)和自然语言的Captioning Loss (Ca)，因此论文名称是CoCa</p>
</li>
<li>
<p>loss精简之后，只需要forwar一次就能计算所有loss，不像之前的方法每个loss需要单独forward，模型可以训练更快了</p>
</li>
<li>
<p>提出了attention_pooling的Pooler，使用MHA模块实现</p>
<ul>
<li>
<p>设置个可学习的query</p>
</li>
<li>
<p>key和value来自Image Encoder输出</p>
</li>
<li>
<p>对于Constrastive Loss的话</p>
</li>
<li>
<p>对于Captioning Loss的话</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha88yNT8vqb3RntPe1TWCXySNDorLSxntKQ7YBib4yJVxOMctN5c5Mgtkw/640?wx_fmt=png" alt=""></p>
<p>从CoCa开始流行通过雷达图展示模型的能力，如下所示</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8vjibA5FQzGn2hvENkyzy4CtiaMMuicicF05WOzlo5nLUiaiaQLomIicboKuzQ/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>视频动作识别的K400和K600</p>
</li>
<li>
<p>图片分类任务ImageNet</p>
</li>
<li>
<p>Caption任务NoCaps</p>
</li>
<li>
<p>VR任务NLVR2</p>
</li>
<li>
<p>VE任务SNLI-VE</p>
</li>
<li>
<p>VQA任务VQAv2</p>
</li>
<li>
<p>图文检索任务Flickr30K和MSCOCO</p>
</li>
</ul>
<p><em>PS: 数据集和指标说明可以查询”多模态任务和评测方法“一节中的表格</em></p>
<h4 id="小结-2">小结</h4>
<p>本节主要介绍了大一统的Stage1，特点是出现了VE, TE和MI三个模块，但是他们直接还是相互独立的</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8bMTXAaoJVeDWyK7g1YTqBecFhsXem65NHxahsuqic7h7j0WH32cibMag/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>(a) VE &gt; TE &gt; MI。代表方法是SCAN，VE部分沿用Fast R-CNN，一般是提前抽取好feature；MI部分人工设计公式，inductive bias过强</p>
</li>
<li>
<p>(b) VE = TE &gt; MI。CLIP方法简单有效，但是数据和训练闭源，训练成本高，FLIP借鉴了MAE的加速技巧对CLIP进行改进</p>
</li>
<li>
<p>(c) VE &gt; MI &gt; TE。ALBEF和CoCa贯彻了VE要比TE更复杂，且MI也要足够复杂的思想，达到了Stage1时期的SOTA</p>
</li>
<li>
<p>(d) MI &gt; VE = TE。ViLT尝鲜VE中使用Patch Projection，虽然效果不好，但是做了很好的开创性工作</p>
</li>
</ul>
<h4 id="大一统stage2-模块共享">大一统Stage2: 模块共享</h4>
<p>Stage1里使用VE, TE和MI三个模块相互配合，已经可以比较好的完成多模态任务了，但是他们在参数层面还是分离的，例如VE和TE的encoder是权重不共享的。如果将VE和TE整合到同一个transformer结构里面，模型精度是否会受到影响呢？</p>
<p>本节就介绍多模态大一统的Stage2，多模态是如何共享transformer模块的，主要介绍4篇论文，VLMO，BLIP，BEiTv3和BLIP2</p>
<h4 id="vlmo">VLMO</h4>
<p>VLMO提出了Mixture-of-Modality-Experts (MoME) Transformer，也叫Multiway Transformers。如下所示</p>
<ul>
<li>
<p>类似SuperNet思想，针对不同模态的输入，激活不同的FNN Expert通路</p>
</li>
<li>
<p>移除了cross-attention，统一使用self-attention，这意味着text和image可以同一个的self-attention编码</p>
</li>
<li>
<p>跟ALBEF一样也有3种loss，ITC，ITM和MLM</p>
</li>
<li>
<p>VLMO还提出了分阶段训练，这样更好的利用单模态的海量数据</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8NpK7kqZQDvsnIfTh5EicJHRagUS67kdBRW6ne9ytSNQF6bo8X2lQGSQ/640?wx_fmt=png" alt=""></p>
<p>分阶段训练</p>
<ul>
<li>
<p>图文匹配数据毕竟数量有限，常用的4M训练集，外加14.1M的CC12M训练集，跟纯文本或者图片动不动上十亿的体量相比，还是太少。</p>
</li>
<li>
<p>于是为了利用这些海量的数据，VLMO使用了分阶段的无监督训练方法</p>
</li>
<li>
<p>有趣的是在图片上做无监督的预训练之后，在文本数据上freeze住self-attention，只finetune FFN，效果貌似还不错。如果顺序对调，发现不work。</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8cyvgELoI0SOiaV7ekR2QzRyNMdIEQP73sy5noqu8ic1mNPc1m3Y0ianhQ/640?wx_fmt=png" alt=""></p>
<h4 id="blip">BLIP</h4>
<p>BLIP整合了ALBEF和VLMO，也使用共享模块，同时做了以下2点改进</p>
<ul>
<li>
<p>模型结构上加上了decoder-only的文本生成能力</p>
</li>
<li>
<p>使用CapFilt模块做数据清洗和过滤，能稳定涨点</p>
</li>
</ul>
<p>网络设计</p>
<p>相比于ALBEF的ITC、ITM和MLM三种loss，BLIP把MLM的完形填空变成了decoder-only的LM loss，原因是要生成caption</p>
<ul>
<li>
<p>对于ITC，添加 [CLS]
的token输出text的特征</p>
</li>
<li>
<p>对于ITM，添加 [Encode]
的token输出二分类概率预测</p>
</li>
<li>
<p>对于LM，添加 [Decode]
的token提示语言模型开始预测token</p>
</li>
</ul>
<p>注意ITC和ITM是共享self-attention模块，这里借鉴了VLMO的思路，但是对于LM，发现还是得self-attention单独训练</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8uuNb3NJicK8CzhFD6oAcUibxSCYiafEqaJLKMGHE1AARe5Eqj8u7cmsdw/640?wx_fmt=png" alt=""></p>
<p>CapFilt方法</p>
<p>BLIP贯彻了data-centric的思路，好好的清洗了一波数据</p>
<ul>
<li>
<p>Step1: 首先利用人工标注的数据和互联网自动爬取数据共同训练初始的模型</p>
</li>
<li>
<p>Step2: 利用人工标注的干净数据做finetune，具体来说做ITC&amp;ITM finetune得到filter，做LM finetune得到Captioner</p>
</li>
<li>
<p>Step3: 最终联合使用Filter和Captioner对数据进行清洗，训练新模型</p>
</li>
<li>
<p>Step4: 重复Step1-Step3若干次</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8DNyIuPTOBA8Nth0cFuQ693U8TLGUWDDVXr8700PqVy2sYia6ZcQhQSg/640?wx_fmt=png" alt=""></p>
<p>得到的Filter和Captioner效果如下，红色为原始caption，绿色为CapFilt生成的caption</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8488MnMRboAlfKe4t2giaQsA29awicX5GicuudmZTMZvBUNhReWMBeCicbw/640?wx_fmt=png" alt=""></p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8JV7QUjQlb1VkYjtO2WGSx9w1nrcUk8Jvr2o0oPWaEicdSRJ1OZFEoTQ/640?wx_fmt=png" alt=""></p>
<p>数据清洗普遍带来1-2个点的提升</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha82JwTBhRBEZaG4BOca2Z8QQyhdsFoZLvOpGk3LW7cHeEHdZVdKOCrSA/640?wx_fmt=png" alt=""></p>
<h4 id="beitv3">BEiTv3</h4>
<p>跟VMLO高度相似，也是Multiway Transformers，改进之处为</p>
<ul>
<li>
<p>把VE完全看成了NLP的一种外语，Pre-train阶段loss精简成只剩下mask-and-predict的范式，无论是image还是text，都用完形填空的方式做预训练</p>
</li>
<li>
<p>text用SentencePiece做tokenization，image用BEiTv2里面学的visual tokens作为重建目标</p>
</li>
<li>
<p>BEiTv3全部使用开源可下载的数据作为训练集，主打一个可复现性</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8pOKnibovU5JqZbupbmbllOUyTibGEH3WYcDib6VW9icClibaQia1qgWnJ2iag/640?wx_fmt=png" alt=""></p>
<p>最终比CoCa效果好一圈</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha89mCJ0IXXyQjFH17axME8MWAicibIMwE0jPelXgupqujFbvYRWPlaV3PA/640?wx_fmt=png" alt=""></p>
<h4 id="blip2">BLIP2</h4>
<p>为了进一步提高多模态的能力，BLIP2做了如下改进</p>
<ul>
<li>
<p>引入了32个可学习的query token，对图片的信息进行了压缩抽取，借助预训练的LLM(如OPT/T5-FLAN)模型，实现了VQA问题效果的巨大提升</p>
</li>
<li>
<p>由于query数量固定，transformer输出token数量跟图片分辨率解耦，训练非常便宜，16张A100 40G即可</p>
</li>
<li>
<p>使用2阶段训练方法，1阶段训练query token，2阶段串联LLM做端到端finetune</p>
</li>
</ul>
<p>训练阶段1</p>
<ul>
<li>
<p>设置32个learnable queries，注意query和text的self-attention是权重共享的，这样有助于query学出近似text语义的token</p>
</li>
<li>
<p>使用常见的ITM, ITC和ITG loss，注意不同loss下self-attention会添加不同的mask</p>
</li>
<li>
<p>Pre-train阶段总计129M数据，同时使用CapFilt技巧对web image做过滤和修正</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8ljcgEQDCU29z8ekpFkRtNubPB3UtOh2AhsmniaNymo1ROSiaYarAU9IQ/640?wx_fmt=png" alt=""></p>
<p>训练阶段2</p>
<ul>
<li>串联上decoder-only或者encoder-decoder的LLM模型做VQA finetune</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha83mjzUqSicdFibTSstbOdVPCo0cWMp7hT19l3vpRWbyZo1wrgCcRUqR1A/640?wx_fmt=png" alt=""></p>
<p>最后在各多模态任务上又霸榜一圈(不过借助了LLM，这算不算外援)</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8R3bUehqLKVoMFqLd5qVVQALs3eeayjgLXtnwIzkhX5ialDakZvMuJCg/640?wx_fmt=png" alt=""></p>
<h4 id="小结-3">小结</h4>
<p>本节主要介绍了如何在同一个transformer block内融合VE，TE和MI，主要思路是Multiway Transformer方法</p>
<ul>
<li>
<p>VLMO首次提出MoME，不同模态通过FFN的不同expert来表达</p>
</li>
<li>
<p>BLIP整合了ALBEF和VLMO，也使用共享模块，并且加上了decoder-only的文本生成能力，使用CapFilt模块做数据清洗和过滤，能稳定涨点</p>
</li>
<li>
<p>BEiTv3跟VMLO高度相似，把VE完全看成了NLP的一种外语，Pre-train阶段loss精简成只剩下mask-and-predict的范式，无论是image还是text，都用完形填空的方式做预训练</p>
</li>
<li>
<p>BLIP2引入了32个可学习的query token，对图片的信息进行了压缩抽取，借助预训练的LLM(如OPT/T5-FLAN)模型，实现了VQA问题效果的巨大提升</p>
</li>
</ul>
<h4 id="大一统stage3-范式统一">大一统Stage3: 范式统一</h4>
<p>个人认为，多模态的终极形态应该是支持任意多模态输入，任意多模态输出。一种解决思路就是把所有模态变成token序列，统一建模成seq2seq任务。</p>
<p>从Stage1和Stage2可以知道，多模态的输入统一成token seq基本已经实现了，无论是image还是video，都可以通过patch partition的方式变成patch token，剩下要解决的就是输出模态表征为token seq。具体来说，需要对Image, Video, Text, Sparse(少量离散的位置坐标), Dense(深度图或者分割图)进行token序列化，这里的</p>
<ul>
<li>
<p>Image、Video和Dense。可以通过AIGC技术把输出token seq变成稠密矩阵。AIGC技术细节将在下一篇《AIGC组成原理》中做展开介绍</p>
</li>
<li>
<p>Text。天然是token seq</p>
</li>
<li>
<p>Sparse。通过坐标离散化编码成token seq</p>
</li>
</ul>
<p>这里对Sparse的编码可能比较陌生，因此先介绍一下pixel2seq工作</p>
<h4 id="pixel2seq">Pixel2seq</h4>
<p>pixel2seq尝试把传统OD问题建模成了输入是图片像素pixel，输出是token seq预测问题</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8KEJkusqPGMHAQXrjzSBicBct4nHE7jbC3e2IevEGh4QtpY5ahicOUhLw/640?wx_fmt=png" alt=""></p>
<ul>
<li>
<p>把每个object框建模为长度为5的序列，形式为</p>
<ul>
<li>
<p>4个corner坐标均匀离散化成，需要个token。例如600x600的图片，可以做到无损表征</p>
</li>
<li>
<p>每个类别用一个token表示，需要个token</p>
</li>
<li>
<p>一共需要种token</p>
</li>
</ul>
</li>
<li>
<p>网络使用encoder-decoder的方式，其中decoder使用casual mask保证只能看到历史的token序列</p>
</li>
</ul>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8lEicbZTu9TbNqTHGD8sCcribj0V69sROibnqVxxfNwUJmSzz7WQbKhCew/640?wx_fmt=png" alt=""></p>
<h4 id="unified-io">Unified-IO</h4>
<p>当我们对Image, Video, Text, Sparse和Dense模态都转换成了token seq之后，统一的IO框架就呼之欲出了，如下所示</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8CzQhCtySwERUOgKBeBFyHElYIDkjPhrm5OHmksEd2Dj73vC8r4fK7g/640?wx_fmt=png" alt=""></p>
<p>常见的多模态任务都可以通过prompt指令来执行，如下展示了常见任务输入和输出模态的类型组合</p>
<p><img src="https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_png/pCFs8q3BZjeSIcUwPicjBRwRYXl6CDha8yyiaFfuIngzqzU5Au0jyCGkD2Fnze4Tx81CatNzvU0pWU18rerx2yNA/640?wx_fmt=png" alt=""></p>
<h4 id="小结-4">小结</h4>
<p>Stage3的范式统一还处于蓬勃发展中，演变过程其实并行于Stage1和Stage2，并没有严格的先后逻辑关系。Unified-IO只是代表了一种发展方向，即用seq2seq统一多模态。还有很多其他优秀的工作例如MetaLM，Uni-Perceiver，PaLi等，篇幅所限就不逐个展开了。</p>
<h4 id="写在最后">写在最后</h4>
<p>本文一共分了5个小节</p>
<ul>
<li>
<p>首先介绍了Vision Transformer的入门知识和相关的应用。包括了ViT(2020.10)，ViT-22B(2023.02)，Swin Transformer(2021.08)，MAE(2021.11)，BEiT(2021.06)，BEiTv2(2022.08)，TimeSFormer(2021.02)，BEVFormer(2022.03)。</p>
</li>
<li>
<p>接着介绍了多模态任务、训练评测数据集和评测方法。包括了Video Action Recognition任务，Image Text Retrival任务，Image Caption任务，Visual QA任务，Visual Reasoning任务，Visual Entailment任务。</p>
</li>
<li>
<p>开始介绍多模态大一统的Stage1，模块独立。从TE，VE和MI三个模块的复杂度关系入手，列举了4种类型的网络结构，包括了SCAN(2018.03)，CLIP(2021.02)，FLIP(2022.12)，ViLT(2021.02)，ALBEF(2021.07)，CoCa(2022.08)。</p>
</li>
<li>
<p>继续介绍多模态大一统的Stage2，模块共享。VLMO(2021.11)开启了TE，VE和MI三个模块共享transformer block的先例，启发了后续BLIP(2022.01)，BEiTv3(2022.08)和BLIP2(2023.01)等工作</p>
</li>
<li>
<p>最后介绍了多模态大一统的Stage3，范式统一。这是一个仍然蓬勃发展的方向，以个人见解列举了Pixel2seq(2021.09)和Unified-IO(2022.06)的范式统一方法。</p>
</li>
</ul>
<p>预告：计划下一篇为《AIGC组成原理》，敬请期待。</p>
<p><em>PS：由于笔者小A并没有亲手撸过上述内容的所有细节，大部分是通过研究代码和精读优秀文章的方式bottom-up总结而来，本质上是个拾人牙慧的知识搬运工，所以终究是纸上谈兵。因此希望各方有实际经验的大佬猛锤，思维碰撞才生火花，真理越辩越明。</em></p>
<p>如果想了解transformer在NLP/多模态/AIGC的算法知识，分布式训练的知识，以及如何在TVM上做PTQ量化和部署，可以关注我aaronxic哟~</p>
<h4 id="系列文章导览">系列文章导览</h4>
<p>[Transformer 101系列] Perplexity指标究竟是什么?</p>
<p>[Transformer 101系列] 初探LLM基座模型</p>
<p>[Transformer 101系列] ChatBot是怎么炼成的?</p>
<h4 id="参考资料">参考资料</h4>
<p>transformer入门 论文阅读(4) Swin Transformer | shifted window,relative position bias详解</p>
<p>ViLT 论文精读【论文精读】_哔哩哔哩_bilibili</p>
<p>多模态论文串讲·上【论文精读·46】_哔哩哔哩_bilibili</p>
<p>多模态论文串讲·下【论文精读·49】_哔哩哔哩_bilibili</p>
<p>BLIP2：下一代多模态模型的雏形</p>
<p>CLIP 论文逐段精读【论文精读】_哔哩哔哩_bilibili</p>
<p><strong>进技术交流群请添加AINLP小助手微信（id: ainlp2)</strong></p>
<p><strong>请备注具体方向+所用到的相关技术点</strong></p>
<pre><code>![](https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_jpg/nW2ZPfuYqSJADkmZ2IX6Z23znAibuEevotDMq9iaMxiapK7jfMibiauGFkycicAJEs6x5U9SGyDJZ0S1tRed9TPNUUDQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)
</code></pre>
<p><strong>关于AINLP</strong></p>
<pre><code>AINLP 是一个有趣有AI的自然语言处理社区，专注于 AI、NLP、机器学习、深度学习、推荐算法等相关技术的分享，主题包括LLM、预训练模型、自动生成、文本摘要、智能问答、聊天机器人、机器翻译、知识图谱、推荐系统、计算广告、招聘信息、求职经验分享等，欢迎关注！加技术交流群请添加AINLP小助手微信(id：ainlp2)，备注工作/研究方向+加群目的。

  


  


![](https://api.allorigins.win/raw?url=https://mmbiz.qpic.cn/mmbiz_jpg/nW2ZPfuYqSKABHCqVVQkVYPrM4XY1vsd0iaeuXzyJnoFc8cibd5mYb4wdA3WMQtiaPVmr0XLZHMuVibqWncibpnTSnQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)
</code></pre>
<p><strong>阅读至此了，分享、点赞、在看三选一吧🙏</strong></p>
<p>更多AI工具，参考<a href="https://ai123.869hr.uk/">Github-AI123</a>，<a href="https://ai123.869hr.uk/">国内AI123</a></p>



          </div>

<<<<<<< HEAD

=======
 可扫如下微信二维码加好友
>>>>>>> HEAD@{1}

<p><img src="/images/aitools/2024/03/qrcode_for_gh_dde1b429630d_258.jpg" alt=""></p>

        </article>

      </div>
    </div>
  </div>
</section>
        </div>
    </div>
    </main>




<script type='text/javascript' src='/assets/js/jquery.ui.touch-punch.min-0.2.2.js' id='jqueryui-touch-js'></script>
<script type='text/javascript' src='/assets/js/clipboard.min-5.6.2.js' id='clipboard-js'></script>
<script type='text/javascript' src='/assets/js/tooltip-extend.js' id='iplaycode-nav-js'></script>
<script type='text/javascript' id='popper-js-extra'>
 

var theme = {"ajaxurl":"","addico":"https:\/\/nav.baidu.cn\/wp-content\/themes\/onenav\/images\/add.png","order":"asc","formpostion":"top","defaultclass":"io-grey-mode","isCustomize":"1","icourl":"","icopng":".png","urlformat":"1","customizemax":"10","newWindow":"0","lazyload":"1","minNav":"1","loading":"1","hotWords":"baidu","classColumns":" col-sm-6 col-md-4 col-xl-5a col-xxl-6a ","apikey":"TWpBeU1UVTNOekk1TWpVMEIvZ1M2bFVIQllUMmxsV1dZelkxQTVPVzB3UW04eldGQmxhM3BNWW14bVNtWk4="};
 
</script>
<script type='text/javascript' src='/assets/js/popper.min.js' id='popper-js'></script>
<script type='text/javascript' src='/assets/js/bootstrap.min-4.3.1.js' id='bootstrap-js'></script>
<script type='text/javascript' src='/assets/js/theia-sticky-sidebar-1.5.0.js' id='sidebar-js'></script>
<script type='text/javascript' src='/assets/js/lazyload.min-12.4.0.js' id='lazyload-js'></script>
<script type='text/javascript' src='/assets/js/fancybox.min-3.5.7.js' id='lightbox-js-js'></script>

<script type='text/javascript' src='/assets/js/app-anim.js' id='appanim-js'></script>

<script type="text/javascript">
    $(document).ready(function(){
        var siteWelcome = $('#loading');
        siteWelcome.addClass('close');
        setTimeout(function() {
            siteWelcome.remove();
        }, 600);
    });
</script>
<script>        
    $(document).ready(function(){
        setTimeout(function () {
            if ($('a.smooth[href="' + window.location.hash + '"]')[0]) {
                $('a.smooth[href="' + window.location.hash + '"]').click();
            }else if (window.location.hash != '') {
                $("html, body").animate({
                    scrollTop: $(window.location.hash).offset().top - 90
                }, {
                    duration: 500,
                    easing: "swing"
                });
            }
        }, 300);
        $(document).on('click','a.smooth',function(ev) {
            if($('#sidebar').hasClass('show') && !$(this).hasClass('change-href')){
                $('#sidebar').modal('toggle');
            }
            if($(this).attr("href").substr(0, 1) == "#"){
                $("html, body").animate({
                    scrollTop: $($(this).attr("href")).offset().top - 90
                }, {
                    duration: 500,
                    easing: "swing"
                });
            }
            if($(this).hasClass('go-search-btn')){
                $('#search-text').focus();
            }
            if(!$(this).hasClass('change-href')){
                var menu =  $("a"+$(this).attr("href"));
                menu.click();
                toTarget(menu.parent().parent(),true,true);
            }
        });
        $(document).on('click','a.tab-noajax',function(ev) {
            var url = $(this).data('link');
            if(url)
                $(this).parents('.d-flex.flex-fill.flex-tab').children('.btn-move.tab-move').show().attr('href', url);
            else
                $(this).parents('.d-flex.flex-fill.flex-tab').children('.btn-move.tab-move').hide();
        });
        
    });
</script>

<script>

(function(){
    if(document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/, "$1") === ''){
        if(new Date().getHours() > 22 || new Date().getHours() < 6){
            document.body.classList.remove('io-black-mode');
            document.body.classList.add('io-grey-mode');
            document.cookie = "night=1;path=/";
            console.log('夜间模式开启');
        }else{
            document.body.classList.remove('night');
            document.cookie = "night=0;path=/";
            console.log('夜间模式关闭');
        }
    }else{
        var night = document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/, "$1") || '0';
        if(night == '0'){
            document.body.classList.remove('night');
        }else if(night == '1'){
            document.body.classList.add('night');
        }
    }
})();

$("#search-bg").css("background", "linear-gradient(#e2c4c4, #d8d8d8)");   
function switchNightMode(){
    var night = document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/, "$1") || '0';
    if(night == '0'){
	$("#search-bg").css("background", "linear-gradient(#e2c4c4, #d8d8d8)");
        document.body.classList.remove('io-grey-mode');
        document.body.classList.add('io-black-mode');
        document.cookie = "night=1;path=/"
        console.log(' ');
        $(".switch-dark-mode").attr("data-original-title","日间模式");
        $(".mode-ico").removeClass("icon-night");
        $(".mode-ico").addClass("icon-light");
    }else{
	$("#search-bg").css("background", "linear-gradient(#4f4040, #1b1d1f)");
        document.body.classList.remove('io-black-mode');
        document.body.classList.add('io-grey-mode');
        document.cookie = "night=0;path=/"
        console.log(' ');
        $(".switch-dark-mode").attr("data-original-title","夜间模式");
        $(".mode-ico").removeClass("icon-light");
        $(".mode-ico").addClass("icon-night");
    }
}
</script>


<script>
    var newsContainer = document.getElementById('news-container');
    var newsItems = document.getElementsByClassName('news-item');
    var currentItem = 0;

    setInterval(function() {
        
        newsItems[currentItem].classList.remove('show');
        newsItems[currentItem].style.transform = 'translateY(-20px)';
        
        currentItem = (currentItem + 1) % newsItems.length;
        newsItems[currentItem].style.transform = 'translateY(' + (newsContainer.offsetHeight - 20) + 'px)';
        setTimeout(function() {
            newsItems[currentItem].classList.add('show');
        }, 500);
    }, 8000);
</script>

</body>
</html>


